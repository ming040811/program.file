<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>나만의 동화 만들기</title>
    <style>
        :root {
            --header-height: 50px;
            --vertical-tabs-width: 65px;
            --asset-panel-width: 200px;
            --timeline-height: 80px;
            --secondary-color: #f4f4f4;
        }

        body {
            font-family: 'Malgun Gothic', sans-serif;
            font-size: 14px;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            background-color: var(--secondary-color);
        }

        .app-header {
            height: var(--header-height);
            background-color: #ffffff;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 20px;
            flex-shrink: 0;
        }

        .export-button {
            padding: 8px 16px;
            background-color: #4F99B2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }

        .app-main {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        .vertical-tabs {
            width: var(--vertical-tabs-width);
            background-color: #F6F6F6;
            border-right: 1px solid #ddd;
            padding-top: 10px;
            flex-shrink: 0;
        }

        .tab-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 70px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            color: #474747;
        }

        .tab-button:focus {
            outline: none;
        }

        .tab-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 55px;
            height: 55px;
            border-radius: 8px;
            transition: background-color 0.2s;
        }

        .tab-button.active .tab-content {
            background-color: #BFDBE4;
        }

        .tab-button img {
            width: 30px;
            height: 30px;
            margin-bottom: 2px;
        }


        .asset-panel {
            width: var(--asset-panel-width);
            background-color: #ffffff;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .asset-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .asset-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        #decorations.asset-list {
             justify-items: center;
        }

        .asset-item {
            width: 100%;
            aspect-ratio: 16 / 9;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #eee;
            object-fit: cover;
        }

        #decorations .asset-item {
            width: 120px;
            aspect-ratio: 1 / 1;
            object-fit: contain;
            padding: 5px;
            box-sizing: border-box;
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .canvas-wrapper {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
            position: relative; 
        }

        #canvas {
            width: 90%;
            aspect-ratio: 16 / 9;
            max-width: 100%;
            max-height: 100%;
            background-color: white;
            position: relative;
            overflow: hidden; 
            background-size: cover;
            background-position: center;
        }

        .decoration-item {
            position: absolute;
            cursor: move;
            user-select: none;
            border: 2px solid transparent;
            transform-origin: center center;
        }

        .decoration-item.selected {
            border-color: #4F99B2;
            z-index: 100;
        }

        .decoration-item img {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background: white;
            border: 2px solid #4F99B2;
            border-radius: 50%;
            display: none;
            box-sizing: border-box;
        }

        .decoration-item.selected .handle {
            display: block;
        }

        .handle.tl { top: -8px; left: -8px; cursor: nwse-resize; }
        .handle.tr { top: -8px; right: -8px; cursor: nesw-resize; }
        .handle.bl { bottom: -8px; left: -8px; cursor: nesw-resize; }
        .handle.br { bottom: -8px; right: -8px; cursor: nwse-resize; }
        .handle.rotator {
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            cursor: grabbing;
        }

        .controls {
            position: absolute;
            top: -48px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            z-index: 101;
            padding: 2px;
        }
        .decoration-item.selected .controls {
            display: flex;
            gap: 2px;
        }

        .controls button {
            border: none;
            background: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
            line-height: 0;
        }
        
        .controls button:hover { 
            background-color: #f0f0f0; 
        }

        .controls button:active {
            background-color: #e0e0e0;
        }

        .controls button img {
            width: 24px;
            height: 24px;
        }

        .snap-guide {
            position: absolute;
            background-color: rgba(255, 77, 77, 0.5); 
            display: none;
            z-index: 999;
            pointer-events: none; 
        }

        .vertical-guide {
            width: 2px; 
            height: 100%; 
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .horizontal-guide {
            height: 2px; 
            width: 100%; 
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .timeline {
            height: var(--timeline-height);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }

        .timeline-strip {
            background-color: #ffffff;
            border-radius: 12px;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .scene {
            height: 45px;
            aspect-ratio: 16 / 9;
            background-color: #e9e9e9;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            background-size: cover;
            background-position: center;
            overflow: hidden; 
        }

        .scene.active {
            border: 2px solid #4F99B2;
        }

        .arrow { color: #ccc; }

        .asset-container::-webkit-scrollbar { width: 8px; }
        .asset-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); }
        .asset-container::-webkit-scrollbar-thumb { background: #e0e0e0; border-radius: 4px; }
        .asset-container::-webkit-scrollbar-thumb:hover { background: #c1c1c1; }
        .asset-container::-webkit-scrollbar-button { display: none; }
    </style>
</head>
<body>

    <header class="app-header">
        <button class="export-button">영상 만들기</button>
    </header>

    <div class="app-main">
        <nav class="vertical-tabs">
            <button class="tab-button active" data-tab="backgrounds">
                <div class="tab-content"><img src="img/배경.png" alt="배경 아이콘">배경</div>
            </button>
            <button class="tab-button" data-tab="decorations">
                <div class="tab-content"><img src="img/꾸미기.png" alt="꾸미기 아이콘">꾸미기</div>
            </button>
        </nav>

        <aside class="asset-panel">
            <div class="asset-container">
                <div id="backgrounds" class="asset-list">
                    <img src="img/낮.png" class="asset-item" data-type="background">
                    <img src="img/밤.png" class="asset-item" data-type="background">
                    <img src="img/비.png" class="asset-item" data-type="background">
                    <img src="img/눈.png" class="asset-item" data-type="background">
                    <img src="img/계단.png" class="asset-item" data-type="background">
                    <img src="img/도시.png" class="asset-item" data-type="background">
                    <img src="img/나무.png" class="asset-item" data-type="background">
                </div>
                <div id="decorations" class="asset-list" style="display: none;">
                    <img src="img/집1.png" class="asset-item" data-type="decoration">
                    <img src="img/성1.png" class="asset-item" data-type="decoration">
                    <img src="img/가로등1.png" class="asset-item" data-type="decoration" data-canvas-src="img/가로등1-2.png">
                    <img src="img/쌍가로등1.png" class="asset-item" data-type="decoration" data-canvas-src="img/쌍가로등1-2.png">
                </div>
            </div>
        </aside>

        <main class="main-content">
            <div class="canvas-wrapper">
                <div id="canvas">
                    <div class="snap-guide vertical-guide"></div>
                    <div class="snap-guide horizontal-guide"></div>
                </div>
            </div>
            <div class="timeline">
                <div class="timeline-strip">
                    <div class="scene active" data-scene="1"></div><span class="arrow">→</span>
                    <div class="scene" data-scene="2"></div><span class="arrow">→</span>
                    <div class="scene" data-scene="3"></div><span class="arrow">→</span>
                    <div class="scene" data-scene="4"></div><span class="arrow">→</span>
                    <div class="scene" data-scene="5"></div><span class="arrow">→</span>
                    <div class="scene" data-scene="6"></div>
                </div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('canvas');
            const verticalGuide = document.querySelector('.vertical-guide');
            const horizontalGuide = document.querySelector('.horizontal-guide');

            const storyData = {
                '1': { background: '', decorations: [] }, '2': { background: '', decorations: [] },
                '3': { background: '', decorations: [] }, '4': { background: '', decorations: [] },
                '5': { background: '', decorations: [] }, '6': { background: '', decorations: [] },
            };
            let currentScene = 1;

            document.querySelectorAll('.asset-item[data-type="decoration"]').forEach(item => {
                item.addEventListener('click', () => {
                    
                    const canvasImageSrc = item.dataset.canvasSrc || item.src;

                    let initialWidth = 400; // 기본값
                    let initialHeight = 400; // 기본값

                    // 가로등1-2 이미지일 경우 비율 조정
                    if (canvasImageSrc.includes('가로등1-2.png')) {
                        const originalWidth = 340;
                        const originalHeight = 1200;
                        initialHeight = 400; // 기준 높이
                        initialWidth = (originalWidth / originalHeight) * initialHeight;
                    } 
                    // 쌍가로등1-2 이미지일 경우 비율 조정
                    else if (canvasImageSrc.includes('쌍가로등1-2.png')) {
                        const originalWidth = 450;
                        const originalHeight = 1200;
                        initialHeight = 400; // 기준 높이
                        initialWidth = (originalWidth / originalHeight) * initialHeight;
                    }
                    // 다른 이미지들은 400x400으로 유지

                    const newDeco = {
                        id: 'deco-' + Date.now(),
                        src: canvasImageSrc,
                        width: initialWidth, 
                        height: initialHeight,
                        x: (canvas.offsetWidth / 2) - (initialWidth / 2),
                        y: (canvas.offsetHeight / 2) - (initialHeight / 2),
                        rotation: 0,
                        scaleX: 1,
                    };
                    storyData[currentScene].decorations.push(newDeco);
                    renderScene(currentScene);
                });
            });

            document.querySelectorAll('.asset-item[data-type="background"]').forEach(item => {
                 item.addEventListener('click', () => {
                     storyData[currentScene].background = item.src;
                     renderScene(currentScene);
                  });
            });

            function renderScene(sceneNumber) {
                const data = storyData[sceneNumber];
                canvas.style.backgroundImage = data.background ? `url(${data.background})` : 'none';
                
                Array.from(canvas.children).forEach(child => {
                    if (child.classList.contains('decoration-item')) {
                        child.remove();
                    }
                });
                data.decorations.forEach(createDecorationElement);
                updateThumbnail(sceneNumber);
            }

            function createDecorationElement(decoData) {
                const item = document.createElement('div');
                item.className = 'decoration-item';
                item.id = decoData.id;
                item.style.left = decoData.x + 'px';
                item.style.top = decoData.y + 'px';
                item.style.width = decoData.width + 'px';
                item.style.height = decoData.height + 'px';
                item.style.transform = `rotate(${decoData.rotation}deg)`;

                const img = document.createElement('img');
                img.src = decoData.src;
                img.style.transform = `scaleX(${decoData.scaleX})`;

                const controls = document.createElement('div');
                controls.className = 'controls';
                controls.innerHTML = `<button class="flip" title="좌우반전"><img src="img/좌우반전.png" alt="좌우반전"></button>
                                      <button class="delete" title="삭제"><img src="img/휴지통.png" alt="삭제"></button>`;
                
                const handles = ['tl', 'tr', 'bl', 'br', 'rotator'].map(type => {
                    const handle = document.createElement('div');
                    handle.className = `handle ${type}`;
                    return handle;
                });

                item.append(img, ...handles, controls);
                canvas.appendChild(item);

                makeInteractive(item);
            }

            function makeInteractive(element) {
                const decoData = storyData[currentScene].decorations.find(d => d.id === element.id);

                element.addEventListener('mousedown', (e) => {
                    document.querySelectorAll('.decoration-item').forEach(el => el.classList.remove('selected'));
                    element.classList.add('selected');
                    e.stopPropagation();
                });

                let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
                element.onmousedown = function(e) {
                    if (e.target.closest('.handle') || e.target.closest('.controls')) return;
                    e.preventDefault();
                    pos3 = e.clientX;
                    pos4 = e.clientY;
                    document.onmouseup = closeDragElement;
                    document.onmousemove = elementDrag;
                };

                function elementDrag(e) {
                    verticalGuide.style.display = 'none';
                    horizontalGuide.style.display = 'none';

                    pos1 = pos3 - e.clientX;
                    pos2 = pos4 - e.clientY;
                    pos3 = e.clientX;
                    pos4 = e.clientY;

                    let newTop = element.offsetTop - pos2;
                    let newLeft = element.offsetLeft - pos1;

                    const snapThreshold = 5; 
                    
                    const canvasWidth = canvas.offsetWidth;
                    const canvasHeight = canvas.offsetHeight;
                    const elementWidth = element.offsetWidth;
                    const elementHeight = element.offsetHeight;

                    const canvasCenterX = canvasWidth / 2;
                    const canvasCenterY = canvasHeight / 2;

                    const elementCenterX = newLeft + elementWidth / 2;
                    const elementCenterY = newTop + elementHeight / 2;

                    let snappedX = false;
                    let snappedY = false;

                    if (Math.abs(elementCenterX - canvasCenterX) < snapThreshold) {
                        newLeft = canvasCenterX - elementWidth / 2;
                        verticalGuide.style.left = `${canvasCenterX}px`;
                        verticalGuide.style.display = 'block';
                        snappedX = true;
                    }

                    if (Math.abs(elementCenterY - canvasCenterY) < snapThreshold) {
                        newTop = canvasCenterY - elementHeight / 2;
                        horizontalGuide.style.top = `${canvasCenterY}px`;
                        horizontalGuide.style.display = 'block';
                        snappedY = true;
                    }

                    if (!snappedX) verticalGuide.style.display = 'none';
                    if (!snappedY) horizontalGuide.style.display = 'none';
                    
                    element.style.top = newTop + "px";
                    element.style.left = newLeft + "px";
                }
                
                function closeDragElement() {
                    document.onmouseup = null;
                    document.onmousemove = null;

                    verticalGuide.style.display = 'none';
                    horizontalGuide.style.display = 'none';

                    decoData.x = element.offsetLeft;
                    decoData.y = element.offsetTop;
                    updateThumbnail(currentScene);
                }
                
                element.querySelectorAll('.handle:not(.rotator)').forEach(handle => {
                    handle.onmousedown = initResize;
                });
                
                function initResize(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const handleType = e.target.classList[1];
                    const rect = element.getBoundingClientRect();
                    const angleRad = decoData.rotation * (Math.PI / 180);
                    const aspectRatio = decoData.width / decoData.height;

                    const corners = getRotatedCorners(rect, angleRad);
                    const oppositeCornerMap = { tl: 'br', tr: 'bl', bl: 'tr', br: 'tl' };
                    const pivot = corners[oppositeCornerMap[handleType]];

                    const isLeft = handleType.includes('l');
                    const isTop = handleType.includes('t');

                    document.onmousemove = (e_move) => {
                        const mouseVector = {
                            x: e_move.clientX - pivot.x,
                            y: e_move.clientY - pivot.y
                        };

                        const rotatedMouseVector = {
                            x: mouseVector.x * Math.cos(-angleRad) - mouseVector.y * Math.sin(-angleRad),
                            y: mouseVector.x * Math.sin(-angleRad) + mouseVector.y * Math.cos(-angleRad)
                        };
                        
                        let newWidth, newHeight;
                        
                        if (Math.abs(rotatedMouseVector.x) / aspectRatio > Math.abs(rotatedMouseVector.y)) {
                            newWidth = Math.abs(rotatedMouseVector.x);
                            newHeight = newWidth / aspectRatio;
                        } else {
                            newHeight = Math.abs(rotatedMouseVector.y);
                            newWidth = newHeight * aspectRatio;
                        }

                        if (newWidth < 20) return;

                        const signX = isLeft ? -1 : 1;
                        const signY = isTop ? -1 : 1;

                        const localCenter = {
                            x: (signX * newWidth) / 2,
                            y: (signY * newHeight) / 2
                        };

                        const rotatedCenterVector = {
                            x: localCenter.x * Math.cos(angleRad) - localCenter.y * Math.sin(angleRad),
                            y: localCenter.x * Math.sin(angleRad) + localCenter.y * Math.cos(angleRad)
                        };
                        
                        const newGlobalCenter = {
                            x: pivot.x + rotatedCenterVector.x,
                            y: pivot.y + rotatedCenterVector.y
                        };

                        const canvasRect = canvas.getBoundingClientRect();
                        const finalLeft = newGlobalCenter.x - (newWidth / 2) - canvasRect.left;
                        const finalTop = newGlobalCenter.y - (newHeight / 2) - canvasRect.top;

                        element.style.width = newWidth + 'px';
                        element.style.height = newHeight + 'px';
                        element.style.left = finalLeft + 'px';
                        element.style.top = finalTop + 'px';
                    };

                    document.onmouseup = () => {
                        document.onmousemove = null;
                        document.onmouseup = null;
                        decoData.width = parseFloat(element.style.width);
                        decoData.height = parseFloat(element.style.height);
                        decoData.x = element.offsetLeft;
                        decoData.y = element.offsetTop;
                        updateThumbnail(currentScene);
                    };
                }

                const rotator = element.querySelector('.rotator');
                rotator.onmousedown = function(e) {
                    e.preventDefault(); e.stopPropagation();
                    const rect = element.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    const startAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * (180 / Math.PI);
                    const startRotation = decoData.rotation;

                    document.onmousemove = function(e_move) {
                        const currentAngle = Math.atan2(e_move.clientY - centerY, e_move.clientX - centerX) * (180 / Math.PI);
                        let newRotation = startRotation + (currentAngle - startAngle);
                        
                        const snapThreshold = 6;
                        const snappedAngle = Math.round(newRotation / 90) * 90;

                        if (Math.abs(newRotation - snappedAngle) < snapThreshold) {
                            newRotation = snappedAngle;
                        }
                        
                        element.style.transform = `rotate(${newRotation}deg)`;
                        decoData.rotation = newRotation;
                    };
                    document.onmouseup = function() {
                        document.onmousemove = null; document.onmouseup = null;
                        updateThumbnail(currentScene);
                    };
                };

                element.querySelector('.flip').addEventListener('click', (e) => {
                    e.stopPropagation();
                    decoData.scaleX *= -1;
                    element.querySelector('img').style.transform = `scaleX(${decoData.scaleX})`;
                    updateThumbnail(currentScene);
                });
                
                element.querySelector('.delete').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = storyData[currentScene].decorations.findIndex(d => d.id === element.id);
                    if (index > -1) {
                        storyData[currentScene].decorations.splice(index, 1);
                        element.remove();
                        updateThumbnail(currentScene);
                    }
                });
            }

            function getRotatedCorners(rect, angle) {
                const center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                const corners = {
                    tl: { x: rect.left, y: rect.top }, tr: { x: rect.right, y: rect.top },
                    bl: { x: rect.left, y: rect.bottom }, br: { x: rect.right, y: rect.bottom }
                };
                for (const key in corners) {
                    corners[key] = rotatePoint(corners[key], center, angle);
                }
                return corners;
            }
            
            function rotatePoint(point, center, angle) {
                const dx = point.x - center.x;
                const dy = point.y - center.y;
                const newX = center.x + dx * Math.cos(angle) - dy * Math.sin(angle);
                const newY = center.y + dx * Math.sin(angle) + dy * Math.cos(angle);
                return { x: newX, y: newY };
            }

            document.addEventListener('mousedown', (e) => {
                if (!e.target.closest('.decoration-item')) {
                    document.querySelectorAll('.decoration-item').forEach(el => el.classList.remove('selected'));
                }
            });

            const tabs = document.querySelectorAll('.tab-button');
            const assetLists = document.querySelectorAll('.asset-list');
            const scenes = document.querySelectorAll('.scene');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    assetLists.forEach(list => list.style.display = 'none');
                    document.getElementById(tab.dataset.tab).style.display = 'grid';
                });
            });

            scenes.forEach(scene => {
                scene.addEventListener('click', () => {
                    scenes.forEach(s => s.classList.remove('active'));
                    scene.classList.add('active');
                    currentScene = scene.dataset.scene;
                    renderScene(currentScene);
                });
            });
            
            function updateThumbnail(sceneNumber) {
                const sceneEl = document.querySelector(`.scene[data-scene="${sceneNumber}"]`);
                if (sceneEl) {
                    sceneEl.innerHTML = ''; 
                    
                    const sceneData = storyData[sceneNumber];
                    sceneEl.style.backgroundImage = sceneData.background ? `url(${sceneData.background})` : 'none';
                    
                    if(canvas.offsetWidth === 0) return;

                    const scaleX = sceneEl.offsetWidth / canvas.offsetWidth;
                    const scaleY = sceneEl.offsetHeight / canvas.offsetHeight;

                    sceneData.decorations.forEach(decoData => {
                        const miniDeco = document.createElement('div');
                        miniDeco.style.position = 'absolute';
                        miniDeco.style.width = (decoData.width * scaleX) + 'px';
                        miniDeco.style.height = (decoData.height * scaleY) + 'px';
                        miniDeco.style.left = (decoData.x * scaleX) + 'px';
                        miniDeco.style.top = (decoData.y * scaleY) + 'px';
                        
                        miniDeco.style.backgroundImage = `url(${decoData.src})`;
                        miniDeco.style.backgroundSize = 'contain';
                        miniDeco.style.backgroundRepeat = 'no-repeat';
                        miniDeco.style.backgroundPosition = 'center';
                        
                        miniDeco.style.transform = `rotate(${decoData.rotation}deg) scaleX(${decoData.scaleX})`;
                        
                        sceneEl.appendChild(miniDeco);
                    });
                }
            }

            document.querySelectorAll('.scene').forEach(scene => {
                updateThumbnail(scene.dataset.scene);
            });
        });
    </script>
</body>
</html>